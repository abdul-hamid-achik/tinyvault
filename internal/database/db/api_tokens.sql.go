// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: api_tokens.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveAPITokensByUser = `-- name: CountActiveAPITokensByUser :one
SELECT COUNT(*) FROM api_tokens
WHERE user_id = $1
  AND revoked_at IS NULL
  AND (expires_at IS NULL OR expires_at > NOW())
`

func (q *Queries) CountActiveAPITokensByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveAPITokensByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAPIToken = `-- name: CreateAPIToken :one
INSERT INTO api_tokens (user_id, name, token_hash, scopes, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, name, token_hash, scopes, last_used_at, expires_at, created_at, revoked_at
`

type CreateAPITokenParams struct {
	UserID    uuid.UUID          `db:"user_id" json:"user_id"`
	Name      string             `db:"name" json:"name"`
	TokenHash []byte             `db:"token_hash" json:"token_hash"`
	Scopes    []string           `db:"scopes" json:"scopes"`
	ExpiresAt pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
}

func (q *Queries) CreateAPIToken(ctx context.Context, arg CreateAPITokenParams) (ApiToken, error) {
	row := q.db.QueryRow(ctx, createAPIToken,
		arg.UserID,
		arg.Name,
		arg.TokenHash,
		arg.Scopes,
		arg.ExpiresAt,
	)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.TokenHash,
		&i.Scopes,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RevokedAt,
	)
	return i, err
}

const deleteAPIToken = `-- name: DeleteAPIToken :exec
DELETE FROM api_tokens WHERE id = $1
`

func (q *Queries) DeleteAPIToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAPIToken, id)
	return err
}

const getAPITokenByHash = `-- name: GetAPITokenByHash :one
SELECT id, user_id, name, token_hash, scopes, last_used_at, expires_at, created_at, revoked_at FROM api_tokens
WHERE token_hash = $1
  AND revoked_at IS NULL
  AND (expires_at IS NULL OR expires_at > NOW())
`

func (q *Queries) GetAPITokenByHash(ctx context.Context, tokenHash []byte) (ApiToken, error) {
	row := q.db.QueryRow(ctx, getAPITokenByHash, tokenHash)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.TokenHash,
		&i.Scopes,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RevokedAt,
	)
	return i, err
}

const getAPITokenByID = `-- name: GetAPITokenByID :one
SELECT id, user_id, name, token_hash, scopes, last_used_at, expires_at, created_at, revoked_at FROM api_tokens WHERE id = $1
`

func (q *Queries) GetAPITokenByID(ctx context.Context, id uuid.UUID) (ApiToken, error) {
	row := q.db.QueryRow(ctx, getAPITokenByID, id)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.TokenHash,
		&i.Scopes,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RevokedAt,
	)
	return i, err
}

const getAPITokenWithUser = `-- name: GetAPITokenWithUser :one
SELECT
    t.id, t.user_id, t.name, t.token_hash, t.scopes, t.last_used_at, t.expires_at, t.created_at, t.revoked_at,
    u.id AS user_id,
    u.github_id,
    u.email,
    u.username,
    u.name,
    u.avatar_url
FROM api_tokens t
JOIN users u ON t.user_id = u.id
WHERE t.token_hash = $1
  AND t.revoked_at IS NULL
  AND (t.expires_at IS NULL OR t.expires_at > NOW())
`

type GetAPITokenWithUserRow struct {
	ID         uuid.UUID          `db:"id" json:"id"`
	UserID     uuid.UUID          `db:"user_id" json:"user_id"`
	Name       string             `db:"name" json:"name"`
	TokenHash  []byte             `db:"token_hash" json:"token_hash"`
	Scopes     []string           `db:"scopes" json:"scopes"`
	LastUsedAt pgtype.Timestamptz `db:"last_used_at" json:"last_used_at"`
	ExpiresAt  pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CreatedAt  time.Time          `db:"created_at" json:"created_at"`
	RevokedAt  pgtype.Timestamptz `db:"revoked_at" json:"revoked_at"`
	UserID_2   uuid.UUID          `db:"user_id_2" json:"user_id_2"`
	GithubID   *int64             `db:"github_id" json:"github_id"`
	Email      string             `db:"email" json:"email"`
	Username   string             `db:"username" json:"username"`
	Name_2     *string            `db:"name_2" json:"name_2"`
	AvatarUrl  *string            `db:"avatar_url" json:"avatar_url"`
}

func (q *Queries) GetAPITokenWithUser(ctx context.Context, tokenHash []byte) (GetAPITokenWithUserRow, error) {
	row := q.db.QueryRow(ctx, getAPITokenWithUser, tokenHash)
	var i GetAPITokenWithUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.TokenHash,
		&i.Scopes,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.UserID_2,
		&i.GithubID,
		&i.Email,
		&i.Username,
		&i.Name_2,
		&i.AvatarUrl,
	)
	return i, err
}

const listAPITokensByUser = `-- name: ListAPITokensByUser :many
SELECT id, user_id, name, token_hash, scopes, last_used_at, expires_at, created_at, revoked_at FROM api_tokens
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAPITokensByUserParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListAPITokensByUser(ctx context.Context, arg ListAPITokensByUserParams) ([]ApiToken, error) {
	rows, err := q.db.Query(ctx, listAPITokensByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiToken{}
	for rows.Next() {
		var i ApiToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.TokenHash,
			&i.Scopes,
			&i.LastUsedAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.RevokedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveAPITokensByUser = `-- name: ListActiveAPITokensByUser :many
SELECT id, user_id, name, token_hash, scopes, last_used_at, expires_at, created_at, revoked_at FROM api_tokens
WHERE user_id = $1
  AND revoked_at IS NULL
  AND (expires_at IS NULL OR expires_at > NOW())
ORDER BY created_at DESC
`

func (q *Queries) ListActiveAPITokensByUser(ctx context.Context, userID uuid.UUID) ([]ApiToken, error) {
	rows, err := q.db.Query(ctx, listActiveAPITokensByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiToken{}
	for rows.Next() {
		var i ApiToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.TokenHash,
			&i.Scopes,
			&i.LastUsedAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.RevokedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAPIToken = `-- name: RevokeAPIToken :exec
UPDATE api_tokens
SET revoked_at = NOW()
WHERE id = $1 AND user_id = $2
`

type RevokeAPITokenParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) RevokeAPIToken(ctx context.Context, arg RevokeAPITokenParams) error {
	_, err := q.db.Exec(ctx, revokeAPIToken, arg.ID, arg.UserID)
	return err
}

const revokeAllAPITokensByUser = `-- name: RevokeAllAPITokensByUser :exec
UPDATE api_tokens
SET revoked_at = NOW()
WHERE user_id = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeAllAPITokensByUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeAllAPITokensByUser, userID)
	return err
}

const updateAPITokenLastUsed = `-- name: UpdateAPITokenLastUsed :exec
UPDATE api_tokens
SET last_used_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateAPITokenLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateAPITokenLastUsed, id)
	return err
}
