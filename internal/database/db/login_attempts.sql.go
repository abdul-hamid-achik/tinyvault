// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: login_attempts.sql

package db

import (
	"context"
	"net/netip"
	"time"
)

const cleanupOldLoginAttempts = `-- name: CleanupOldLoginAttempts :exec
DELETE FROM login_attempts
WHERE created_at < $1
`

func (q *Queries) CleanupOldLoginAttempts(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.Exec(ctx, cleanupOldLoginAttempts, createdAt)
	return err
}

const countRecentFailedAttempts = `-- name: CountRecentFailedAttempts :one
SELECT COUNT(*) FROM login_attempts
WHERE email = $1
  AND success = false
  AND created_at > $2
`

type CountRecentFailedAttemptsParams struct {
	Email     string    `db:"email" json:"email"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
}

func (q *Queries) CountRecentFailedAttempts(ctx context.Context, arg CountRecentFailedAttemptsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentFailedAttempts, arg.Email, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLastSuccessfulLogin = `-- name: GetLastSuccessfulLogin :one
SELECT id, email, ip_address, success, created_at FROM login_attempts
WHERE email = $1 AND success = true
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLastSuccessfulLogin(ctx context.Context, email string) (LoginAttempt, error) {
	row := q.db.QueryRow(ctx, getLastSuccessfulLogin, email)
	var i LoginAttempt
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.IpAddress,
		&i.Success,
		&i.CreatedAt,
	)
	return i, err
}

const recordLoginAttempt = `-- name: RecordLoginAttempt :exec
INSERT INTO login_attempts (email, ip_address, success)
VALUES ($1, $2, $3)
`

type RecordLoginAttemptParams struct {
	Email     string      `db:"email" json:"email"`
	IpAddress *netip.Addr `db:"ip_address" json:"ip_address"`
	Success   bool        `db:"success" json:"success"`
}

func (q *Queries) RecordLoginAttempt(ctx context.Context, arg RecordLoginAttemptParams) error {
	_, err := q.db.Exec(ctx, recordLoginAttempt, arg.Email, arg.IpAddress, arg.Success)
	return err
}
